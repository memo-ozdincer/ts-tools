#!/usr/bin/env python3
"""Plot trajectory statistics for Newton-Raphson minimization grid runs.

This script reads the *_trajectory.json files generated by the grid search,
and creates six plots per trajectory:
1) Trust radius vs actual displacement
2) Force norm and retries
3) Hessian condition number
4) Largest vibrational eigenvalue over time
5) Smallest vibrational eigenvalue over time
6) Cascading n_neg counts over time for all logged thresholds
"""

import argparse
import json
from pathlib import Path
import numpy as np

import matplotlib

# Set matplotlib backend to Agg for HPC usage
matplotlib.use('Agg')
import matplotlib.pyplot as plt


def _get_threshold_keys(trajectory):
    """Return sorted list of (threshold_float, key_name) pairs in trajectory records."""
    found = set()
    for step in trajectory:
        for key in step:
            if key.startswith("n_neg_at_"):
                try:
                    thr = float(key[len("n_neg_at_"):])
                except ValueError:
                    continue
                found.add((thr, key))
    return sorted(found, key=lambda x: x[0])


def _select_evenly_spaced(files, n_select):
    """Pick up to n_select files, evenly spaced across the full file list."""
    if n_select <= 0 or len(files) <= n_select:
        return files
    idx = np.linspace(0, len(files) - 1, num=n_select, dtype=int)
    # Keep order deterministic and remove duplicates if any
    seen = set()
    selected = []
    for i in idx.tolist():
        if i not in seen:
            seen.add(i)
            selected.append(files[i])
    return selected


def plot_trajectory(traj_path: Path, output_dir: Path):
    with open(traj_path) as f:
        data = json.load(f)
    
    trajectory = data.get("trajectory", [])
    if not trajectory:
        return
    
    sample_id = data.get("sample_id", "unknown_sample")
    method = data.get("method", "unknown_method")
    
    steps = [t["step"] for t in trajectory]
    trust_radii = [t.get("trust_radius", np.nan) for t in trajectory]
    actual_disps = [t.get("actual_step_disp", np.nan) for t in trajectory]
    hit_radius = [t.get("hit_trust_radius", False) for t in trajectory]
    retries = [t.get("retries", 0) for t in trajectory]
    cond_nums = [t.get("cond_num", np.nan) for t in trajectory]
    force_norms = [t.get("force_norm", np.nan) for t in trajectory]
    max_vib_evals = [t.get("max_vib_eval", np.nan) for t in trajectory]
    min_vib_evals = [t.get("min_vib_eval", np.nan) for t in trajectory]
    cascade_thresholds = _get_threshold_keys(trajectory)
    
    fig, axs = plt.subplots(6, 1, figsize=(12, 22), sharex=True)
    fig.suptitle(f"Minimization Trajectory: {sample_id} ({method})", fontsize=14)
    
    # Plot 1: Trust Radius vs Actual Displacement
    ax = axs[0]
    ax.plot(steps, trust_radii, label="Trust Radius Limit", linestyle="--", color="blue", alpha=0.7)
    ax.plot(steps, actual_disps, label="Actual Max Atom Displacement", color="green")
    
    # Highlight points where trust radius was hit
    hit_steps = [s for s, h in zip(steps, hit_radius) if h]
    hit_disps = [d for d, h in zip(actual_disps, hit_radius) if h]
    if hit_steps:
        ax.scatter(hit_steps, hit_disps, color="red", zorder=5, label="Hit Trust Radius")
        
    ax.set_ylabel("Displacement (Å)")
    ax.set_yscale('log')
    ax.legend(loc="upper right")
    ax.grid(True, alpha=0.3)
    ax.set_title("Step Size Evolution")
    
    # Plot 2: Retries and Force Norm
    ax2 = axs[1]
    color = 'tab:orange'
    ax2.set_ylabel('Force Norm (eV/Å)', color=color)
    ax2.plot(steps, force_norms, color=color, label="Force Norm")
    ax2.tick_params(axis='y', labelcolor=color)
    ax2.set_yscale('log')
    
    ax2_twin = ax2.twinx()
    color = 'tab:purple'
    ax2_twin.set_ylabel('Retries (rejected steps)', color=color)
    ax2_twin.bar(steps, retries, color=color, alpha=0.3, label="Retries")
    ax2_twin.tick_params(axis='y', labelcolor=color)
    
    ax2.set_title("Forces and Step Retries")
    ax2.grid(True, alpha=0.3)
    
    # Plot 3: Condition Number
    ax3 = axs[2]
    ax3.plot(steps, cond_nums, color="brown")
    ax3.set_ylabel("Condition Number")
    ax3.set_yscale('log')
    ax3.set_title("Hessian Condition Number (|λ_max| / |λ_min|)")
    ax3.grid(True, alpha=0.3)

    # Plot 4: Maximum Eigenvalue
    ax4 = axs[3]
    ax4.plot(steps, max_vib_evals, color="steelblue")
    ax4.set_ylabel("Max Eigenvalue")
    ax4.set_title("Largest Vibrational Eigenvalue Over Time")
    ax4.grid(True, alpha=0.3)

    # Plot 5: Minimum Eigenvalue
    ax5 = axs[4]
    ax5.plot(steps, min_vib_evals, color="darkred")
    ax5.axhline(0.0, color="black", linewidth=1.0, alpha=0.4)
    ax5.set_ylabel("Min Eigenvalue")
    ax5.set_title("Smallest Vibrational Eigenvalue Over Time")
    ax5.grid(True, alpha=0.3)

    # Plot 6: Cascading n_neg thresholds over full trajectory
    ax6 = axs[5]
    style_map = {
        0.01: ("black", "--"),
        0.001: ("hotpink", "-"),
    }
    if cascade_thresholds:
        for thr, key in cascade_thresholds:
            values = [t.get(key, np.nan) for t in trajectory]
            color, linestyle = style_map.get(thr, (None, "-"))
            ax6.plot(
                steps,
                values,
                label=f"n_neg < -{thr:g}",
                color=color,
                linestyle=linestyle,
                linewidth=1.8 if thr in style_map else 1.2,
                alpha=0.95 if thr in style_map else 0.8,
            )
        ax6.legend(loc="upper right", ncol=2, fontsize=8)
    ax6.set_ylabel("Count")
    ax6.set_xlabel("Step")
    ax6.set_title("Negative-Eigenvalue Counts at Cascade Thresholds")
    ax6.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    out_file = output_dir / f"{traj_path.stem}.png"
    plt.savefig(out_file, dpi=150, bbox_inches='tight')
    plt.close(fig)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--grid-dir", required=True, help="Directory containing grid subfolders with diagnostics")
    parser.add_argument("--output-dir", required=True, help="Directory to save PNG plots")
    parser.add_argument(
        "--n-plots",
        type=int,
        default=10,
        help="Number of trajectories to plot (evenly spaced across all found files). 0 = plot all.",
    )
    args = parser.parse_args()
    
    grid_dir = Path(args.grid_dir)
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Find all trajectory json files in the grid directory structure
    traj_files = list(grid_dir.rglob("*_trajectory.json"))
    
    if not traj_files:
        print(f"No trajectory files found in {grid_dir}")
        return

    traj_files = sorted(traj_files)
    selected_files = _select_evenly_spaced(traj_files, args.n_plots)

    print(f"Found {len(traj_files)} trajectory files.")
    print(f"Plotting {len(selected_files)} trajectories.")

    for i, traj_file in enumerate(selected_files, start=1):
        # Create subdirectories in the output folder mirroring the grid structure
        rel_path = traj_file.relative_to(grid_dir)
        combo_tag = rel_path.parts[0] if len(rel_path.parts) > 1 else "unknown_combo"
        
        combo_out_dir = output_dir / combo_tag
        combo_out_dir.mkdir(parents=True, exist_ok=True)
        
        plot_trajectory(traj_file, combo_out_dir)
        if i % 5 == 0 or i == len(selected_files):
            print(f"Processed {i}/{len(selected_files)} files...")
            
    print(f"Done! Plots saved to {output_dir}")

if __name__ == "__main__":
    main()
