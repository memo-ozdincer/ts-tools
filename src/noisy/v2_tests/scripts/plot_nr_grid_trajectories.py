#!/usr/bin/env python3
"""Plot trajectory statistics for Newton-Raphson minimization grid runs.

This script reads the *_trajectory.json files generated by the grid search,
and creates six plots per trajectory:
1) Trust radius vs actual displacement
2) Force norm and retries
3) Hessian condition number
4) Largest |eigenvalue| used in condition-number numerator
5) Smallest |eigenvalue| used in condition-number denominator
6) Cascading n_neg counts over time for all logged thresholds
"""

import argparse
import json
from pathlib import Path
import numpy as np

import matplotlib

# Set matplotlib backend to Agg for HPC usage
matplotlib.use('Agg')
import matplotlib.pyplot as plt


def _get_threshold_keys(trajectory):
    """Return sorted list of (threshold_float, key_name) pairs in trajectory records."""
    found = set()
    for step in trajectory:
        for key in step:
            if key.startswith("n_neg_at_"):
                try:
                    thr = float(key[len("n_neg_at_"):])
                except ValueError:
                    continue
                found.add((thr, key))
    return sorted(found, key=lambda x: x[0])


def _select_evenly_spaced(files, n_select):
    """Pick up to n_select files, evenly spaced across the full file list."""
    if n_select <= 0 or len(files) <= n_select:
        return files
    idx = np.linspace(0, len(files) - 1, num=n_select, dtype=int)
    # Keep order deterministic and remove duplicates if any
    seen = set()
    selected = []
    for i in idx.tolist():
        if i not in seen:
            seen.add(i)
            selected.append(files[i])
    return selected


def _is_converged_payload(data):
    """Infer strict convergence (n_neg == 0) from trajectory payload."""
    final_cascade = data.get("final_cascade")
    if isinstance(final_cascade, dict) and "n_neg_at_0.0" in final_cascade:
        return final_cascade.get("n_neg_at_0.0") == 0

    final_neg_vib = data.get("final_neg_vib")
    if final_neg_vib is not None:
        return final_neg_vib == 0

    trajectory = data.get("trajectory", [])
    if trajectory:
        last = trajectory[-1]
        n_neg = last.get("n_neg_at_0.0")
        if n_neg is None:
            n_neg = last.get("n_neg_evals")
        if n_neg is not None:
            return n_neg == 0

    return False


def _classify_trajectory_file(traj_path):
    """Return True if converged, False otherwise."""
    try:
        with open(traj_path) as f:
            data = json.load(f)
    except Exception:
        return False
    return _is_converged_payload(data)


def _interleave_lists(a, b):
    out = []
    i = j = 0
    while i < len(a) or j < len(b):
        if i < len(a):
            out.append(a[i])
            i += 1
        if j < len(b):
            out.append(b[j])
            j += 1
    return out


def _select_balanced_trajectories(traj_files, n_select):
    """Select trajectories with convergence-aware balancing."""
    if n_select <= 0 or len(traj_files) <= n_select:
        conv = [p for p in traj_files if _classify_trajectory_file(p)]
        return traj_files, len(conv), len(traj_files) - len(conv)

    converged = []
    non_converged = []
    for path in traj_files:
        if _classify_trajectory_file(path):
            converged.append(path)
        else:
            non_converged.append(path)

    # Equal split when possible; otherwise include all of smaller class.
    target_conv = min(len(converged), n_select // 2)
    target_non = min(len(non_converged), n_select // 2)

    used = target_conv + target_non
    remaining = n_select - used

    if remaining > 0:
        # Prefer filling from converged first (upsample good runs).
        extra_conv = min(remaining, len(converged) - target_conv)
        target_conv += extra_conv
        remaining -= extra_conv

    if remaining > 0:
        extra_non = min(remaining, len(non_converged) - target_non)
        target_non += extra_non
        remaining -= extra_non

    selected_conv = _select_evenly_spaced(converged, target_conv)
    selected_non = _select_evenly_spaced(non_converged, target_non)
    selected = _interleave_lists(selected_conv, selected_non)[:n_select]
    return selected, len(selected_conv), len(selected_non)


def _robust_ylim(values, *, iqr_mult=3.0, include=None):
    """Compute robust y-limits by clipping IQR outliers."""
    arr = np.asarray(values, dtype=float)
    arr = arr[np.isfinite(arr)]
    if arr.size == 0:
        return None

    q1, q3 = np.quantile(arr, [0.25, 0.75])
    iqr = q3 - q1
    if iqr > 0:
        low_clip = q1 - iqr_mult * iqr
        high_clip = q3 + iqr_mult * iqr
        core = arr[(arr >= low_clip) & (arr <= high_clip)]
        if core.size > 0:
            low = float(core.min())
            high = float(core.max())
        else:
            low = float(arr.min())
            high = float(arr.max())
    else:
        low = float(np.quantile(arr, 0.05))
        high = float(np.quantile(arr, 0.95))

    if include is not None:
        for v in include:
            if np.isfinite(v):
                low = min(low, float(v))
                high = max(high, float(v))

    if low == high:
        pad = abs(low) * 0.1 if low != 0 else 1.0
        return low - pad, high + pad

    pad = 0.08 * (high - low)
    return low - pad, high + pad


def _robust_log_ylim(values, *, iqr_mult=3.0):
    """Robust y-limits in log-space for positive-valued series."""
    arr = np.asarray(values, dtype=float)
    arr = arr[np.isfinite(arr) & (arr > 0)]
    if arr.size == 0:
        return None

    log_arr = np.log10(arr)
    lim = _robust_ylim(log_arr, iqr_mult=iqr_mult)
    if lim is None:
        return None
    return float(10 ** lim[0]), float(10 ** lim[1])


def _first_converged_step(trajectory):
    """Return first step index where strict negative-eigenvalue count is zero."""
    for step in trajectory:
        n_neg = step.get("n_neg_at_0.0")
        if n_neg is None:
            n_neg = step.get("n_neg_evals")
        if n_neg == 0:
            return step.get("step")
    return None


def plot_trajectory(traj_path: Path, output_dir: Path):
    with open(traj_path) as f:
        data = json.load(f)
    
    trajectory = data.get("trajectory", [])
    if not trajectory:
        return
    
    sample_id = data.get("sample_id", "unknown_sample")
    method = data.get("method", "unknown_method")
    
    steps = [t["step"] for t in trajectory]
    trust_radii = [t.get("trust_radius", np.nan) for t in trajectory]
    actual_disps = [t.get("actual_step_disp", np.nan) for t in trajectory]
    hit_radius = [t.get("hit_trust_radius", False) for t in trajectory]
    retries = [t.get("retries", 0) for t in trajectory]
    cond_nums = [t.get("cond_num", np.nan) for t in trajectory]
    force_norms = [t.get("force_norm", np.nan) for t in trajectory]

    # Reconstruct the exact eigenvalue magnitudes used by cond_num:
    # cond_num = max_abs_eval / min_abs_eval
    # max_abs_eval can be reconstructed from min/max signed eigenvalues.
    max_abs_vib_evals = []
    min_abs_vib_evals = []
    for t in trajectory:
        min_eval = t.get("min_vib_eval", np.nan)
        max_eval = t.get("max_vib_eval", np.nan)
        cond = t.get("cond_num", np.nan)

        if np.isfinite(min_eval) and np.isfinite(max_eval):
            max_abs = max(abs(float(min_eval)), abs(float(max_eval)))
        else:
            max_abs = np.nan

        if np.isfinite(cond) and cond > 0 and np.isfinite(max_abs):
            min_abs = np.nan if np.isinf(cond) else (max_abs / float(cond))
        else:
            min_abs = np.nan

        max_abs_vib_evals.append(max_abs)
        min_abs_vib_evals.append(min_abs)

    cascade_thresholds = _get_threshold_keys(trajectory)
    converged_step = _first_converged_step(trajectory)

    fig, axs = plt.subplots(3, 2, figsize=(16, 12), sharex='col')
    fig.suptitle(f"Minimization Trajectory: {sample_id} ({method})", fontsize=14)

    ax = axs[0, 0]
    ax2 = axs[0, 1]
    ax3 = axs[1, 0]
    ax4 = axs[1, 1]
    ax5 = axs[2, 0]
    ax6 = axs[2, 1]

    # Plot 1: Trust Radius vs Actual Displacement
    ax.plot(steps, trust_radii, label="Trust Radius Limit", linestyle="--", color="blue", alpha=0.7)
    ax.plot(steps, actual_disps, label="Actual Max Atom Displacement", color="green")
    if converged_step is not None:
        ax.axvline(
            converged_step,
            color="green",
            linestyle="--",
            linewidth=1.3,
            alpha=0.9,
            label="Converged (n_neg=0)",
        )
    
    # Highlight points where trust radius was hit
    hit_steps = [s for s, h in zip(steps, hit_radius) if h]
    hit_disps = [d for d, h in zip(actual_disps, hit_radius) if h]
    if hit_steps:
        ax.scatter(hit_steps, hit_disps, color="red", zorder=5, label="Hit Trust Radius")
        
    ax.set_ylabel("Displacement (Å)")
    ax.set_yscale('log')
    ax.legend(loc="upper right")
    ax.grid(True, alpha=0.3)
    ax.set_title("Step Size Evolution")
    
    # Plot 2: Retries and Force Norm
    color = 'tab:orange'
    ax2.set_ylabel('Force Norm (eV/Å)', color=color)
    ax2.plot(steps, force_norms, color=color, label="Force Norm")
    ax2.tick_params(axis='y', labelcolor=color)
    ax2.set_yscale('log')
    
    ax2_twin = ax2.twinx()
    color = 'tab:purple'
    ax2_twin.set_ylabel('Retries (rejected steps)', color=color)
    ax2_twin.bar(steps, retries, color=color, alpha=0.3, label="Retries")
    ax2_twin.tick_params(axis='y', labelcolor=color)
    
    ax2.set_title("Forces and Step Retries")
    ax2.grid(True, alpha=0.3)
    if converged_step is not None:
        ax2.axvline(converged_step, color="green", linestyle="--", linewidth=1.3, alpha=0.9)
    
    # Plot 3: Condition Number
    ax3.plot(steps, cond_nums, color="brown")
    ax3.set_ylabel("Condition Number")
    ax3.set_yscale('log')
    ax3.set_title("Hessian Condition Number (|λ_max| / |λ_min|)")
    ax3.grid(True, alpha=0.3)
    if converged_step is not None:
        ax3.axvline(converged_step, color="green", linestyle="--", linewidth=1.3, alpha=0.9)
    cond_ylim = _robust_log_ylim(cond_nums, iqr_mult=3.0)
    if cond_ylim is not None:
        ax3.set_ylim(*cond_ylim)

    # Plot 4: Largest absolute eigenvalue used in cond_num numerator
    ax4.plot(steps, max_abs_vib_evals, color="steelblue")
    ax4.set_ylabel("Eigenvalue Magnitude")
    ax4.set_yscale('log')
    ax4.set_title("Largest |Eigenvalue| Used in Condition Number")
    ax4.grid(True, alpha=0.3)
    if converged_step is not None:
        ax4.axvline(converged_step, color="green", linestyle="--", linewidth=1.3, alpha=0.9)
    max_abs_ylim = _robust_log_ylim(max_abs_vib_evals, iqr_mult=3.0)
    if max_abs_ylim is not None:
        ax4.set_ylim(*max_abs_ylim)

    # Plot 5: Smallest absolute eigenvalue used in cond_num denominator
    ax5.plot(steps, min_abs_vib_evals, color="darkred")
    ax5.set_ylabel("Eigenvalue Magnitude")
    ax5.set_yscale('log')
    ax5.set_title("Smallest |Eigenvalue| Used in Condition Number")
    ax5.grid(True, alpha=0.3)
    if converged_step is not None:
        ax5.axvline(converged_step, color="green", linestyle="--", linewidth=1.3, alpha=0.9)
    min_abs_ylim = _robust_log_ylim(min_abs_vib_evals, iqr_mult=3.0)
    if min_abs_ylim is not None:
        ax5.set_ylim(*min_abs_ylim)
    ax5.set_xlabel("Step")

    # Plot 6: Cascading n_neg thresholds over full trajectory
    style_map = {
        0.01: ("black", "--"),
        0.001: ("hotpink", "-"),
    }

    # Explicit total-negative count (strict threshold < 0), distinct styling.
    strict_total = [t.get("n_neg_at_0.0", t.get("n_neg_evals", np.nan)) for t in trajectory]
    ax6.plot(
        steps,
        strict_total,
        label="n_neg total (<0)",
        color="tab:green",
        linestyle="-",
        linewidth=2.4,
        alpha=0.95,
        zorder=3,
    )

    if cascade_thresholds:
        for thr, key in cascade_thresholds:
            # Avoid duplicating the strict total line; it's plotted explicitly above.
            if np.isclose(thr, 0.0):
                continue
            values = [t.get(key, np.nan) for t in trajectory]
            color, linestyle = style_map.get(thr, (None, "-"))
            ax6.plot(
                steps,
                values,
                label=f"n_neg < -{thr:g}",
                color=color,
                linestyle=linestyle,
                linewidth=1.8 if thr in style_map else 1.2,
                alpha=0.95 if thr in style_map else 0.8,
            )
        ax6.legend(loc="upper right", ncol=2, fontsize=8)
    ax6.set_ylabel("Count")
    ax6.set_xlabel("Step")
    ax6.set_title("Negative-Eigenvalue Counts at Cascade Thresholds")
    ax6.grid(True, alpha=0.3)
    if converged_step is not None:
        ax6.axvline(converged_step, color="green", linestyle="--", linewidth=1.3, alpha=0.9)
    
    plt.tight_layout()
    
    out_file = output_dir / f"{traj_path.stem}.png"
    plt.savefig(out_file, dpi=150, bbox_inches='tight')
    plt.close(fig)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--grid-dir", required=True, help="Directory containing grid subfolders with diagnostics")
    parser.add_argument("--output-dir", required=True, help="Directory to save PNG plots")
    parser.add_argument(
        "--n-plots",
        type=int,
        default=10,
        help="Number of trajectories to plot (evenly spaced across all found files). 0 = plot all.",
    )
    args = parser.parse_args()
    
    grid_dir = Path(args.grid_dir)
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Find all trajectory json files in the grid directory structure
    traj_files = list(grid_dir.rglob("*_trajectory.json"))
    
    if not traj_files:
        print(f"No trajectory files found in {grid_dir}")
        return

    traj_files = sorted(traj_files)
    selected_files, n_conv_sel, n_non_sel = _select_balanced_trajectories(
        traj_files, args.n_plots
    )

    print(f"Found {len(traj_files)} trajectory files.")
    print(
        f"Plotting {len(selected_files)} trajectories "
        f"(converged={n_conv_sel}, non_converged={n_non_sel})."
    )

    for i, traj_file in enumerate(selected_files, start=1):
        # Create subdirectories in the output folder mirroring the grid structure
        rel_path = traj_file.relative_to(grid_dir)
        combo_tag = rel_path.parts[0] if len(rel_path.parts) > 1 else "unknown_combo"
        
        combo_out_dir = output_dir / combo_tag
        combo_out_dir.mkdir(parents=True, exist_ok=True)
        
        plot_trajectory(traj_file, combo_out_dir)
        if i % 5 == 0 or i == len(selected_files):
            print(f"Processed {i}/{len(selected_files)} files...")
            
    print(f"Done! Plots saved to {output_dir}")

if __name__ == "__main__":
    main()
